
### 들어가며
```
애그리거트 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는
리포지토리는 애그리거트 단위로 존재한다. Order와 OrderLine이 물리적으로
별도의 DB테이블에 저장된다고 해서 리포지토리를 각각 만들지는 않는다.

그러나 JPA나 팀내 DB설계 수준을 따른다면 DB테이블 구조에 맞게 모델을 변경해야 한다.
밸류타입인 도메인 모델을 @Component가 아닌  @Entity를 이용해야하는 경우도 있다.
Order애그리거트와 관련된 테이블이 3개라면 Order저장할 때 애그리거트 루트와 매핑되는 테이블
뿐만 아니라 애그리거트에 속한 모든 구성요소에 매핑된 테이블에 저장해야한다.
그리고 가져오는것도 그렇고 가져올때 전부다 가져오지 않는다면 오류가 생긴다
```
```java
Order order = orderRepository.findById(orderId);
order.cancel(); // 만약 완전하게 전부 다 가져오지 않는다면 오류발생
애그리거트의 상태 변경되면 다 정합성 맞추는것도 해야함 한곳에 대한 변경만 반영되면 데이터 일관성 깨짐
```

### ID를 이용한 애그리거트 참조
애그리거트 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같다.



## ORM으로 애그리거트 루트에 대한 참조시 문제 3가지

### 편한 탐색 오용
한 애그리거트 내부에서 다른 애그리거트 객체에 접근이 가능하니 애그리거트 상태를 쉽게 변경이가능하는 문제
이게 왜 문제냐면 트랜잭션 범위에서 언급한 것처럼 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.


### 성능
JPA사용하면 즉시로딩 지연로딩 전략을 고려해야 한다.
상태변경만 하는경우 지연로딩이 유리하고, 한 화면에 다 보여줘야한다면 즉시로딩이 유리하다

### 확장
초기에는 단일서버 단일 DBMS가 가능하다.
그러나 트래픽이 몰려 도메인을 분리한 경우 도메인마다 DBMS를 다르게 사용한다면
더 이상은 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.

### 해결방안
이런 세가지 문제를 완화할 때 사용할 수 있는것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다
DB테이블에서 외래키로 참조하는 것과 비슷하게 ID를 이용한 참조는 다른 애그리거트를 참조할 때 ID를 이용한다 
ID참조의 장점은 모든 객체가 참조로 연결되지 않아 위의 3문제를 해결하며 애그리거트의 경계를 명확히 하고
물리적인 연결을 제거하기 때문에 모델의 복잡성을 낮춰주고 애그리거트간의 의존성을 제거하므로 응집도를 높여준다.
구현 복잡도도 낮아지고
