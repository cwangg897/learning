
#### 한 문단에 한 주체 (케이스를 나눠라)
```
하나의 테스트는 하나의 주제만을 가져야한다
분기문 반복문(논리문) 분기를 가른다는것도 2가지이상이 존재한다는것이다
반복문도 테스트코드를 읽는사람이 논리구조(이해)가 들고아야하기때문에 좋은테스트가 아니다
어떤 테스트를 하고자하는지 방해할 수 있다
Parameterize테스트하는것이 훨씬 더 좋다
즉 DisplayName을 한문장으로 구성한다면 이게 자동으로 지켜진다
```

#### 완벽하게 제어하기
```
현재시간은 동적으로바뀐다 따라서 외부로 뺴서 제어가 가능하게 만들자.
외부로 뺀다면(분리) 테스트 범위가 커진다
외부시스템 연동은 Mocking, 랜덤값도 외부로 빼기
웬만하면 LocalDateTime.now()를 지양하는게 좋다.
한번쓰면 번진다 (주문기록에 대한거여도 now()는 동적이니까 빼자)
```

#### 테스트 환경의 독립성을 보장하자
```
이게 무슨말이냐면 given절에서 테스트행위를 하기위해 이전 준비과정을 만드는데
이런 테스트환경에서 다른API를 끌어다가 쓸때 결합도가 증가할 수 있는데
테스트의 관심사는 주문생성인데 재고차감이라는 다른 행위를 끌어다 사용함으로서
2가지가 들어있는것이다.
given절에서 테스트깨지니까 테스트주제랑 안맞다.
최대한 테스트환경조성할때 생성자 기반으로 구성하는게 좋다
순수 빌더랑 생성자를 지향해라 팩토리 메서드를 굳이 하지마라
목적이 들어간 생성이기때문에 테스트에서는 팩토리 메서드 지양해라
순수 빌더, 생성자를 사용해라

```
![image](https://github.com/cwangg897/learning/assets/79621675/d2b07439-96b8-4bdf-9765-b2fcd628675c)


#### 테스트 간 독립성을 보장하자
```
환경의 독립성과 테스트 간 독립성 차이는
테스트간 = 두 개이상의 테스트
즉 두가지이상의 테스트가 하나의 자원을 공유하는것은 좋지 않다.
다른사람이 보면은 모른다.
A테스트가 성공해야 B테스트가 성공한다 이런거 절대 하지말기
하나의 객체가 변화하는 모습을 테스트하는경우는 DynamicTest를 사용해라
```

#### 한 눈에 들어오는 TestFixture 구성하기
```
테스트환경을 위해서 원하는 상태로 고정시킨 값으로 given절에서 생성했던 객체를 Fixture라고 생각
setup이나 given데이터들 하나의 테스트에서 여러 테스트에서 작성할때 given데이터가 겹치는경우
beforeEach를사용하는데 공유객체를 사용하는것과 같은 결합도를 만드는 문제를 발생시킨다
테스트간 결합도를 생기게 만들어서 픽쳐를 수정할때 다 영향을 미치기때문에 사용한하는게 좋다
setUp에 구성했다가 테스트 클래스가 엄청길어진다면 given절 보면 무엇이 없으면 가독성이 떨어진다
문서로서의 테스트 기능이 매우중요하다

각 테스트 입장에서 봤을때 아예 몰라도 테스트 내용을 이해하는 데에 문제가 없는가?
수정해도 모든 테스트에 영향을 주지 않는가?
이 2개를 만족하면 beforeEach에 가도된다

given데이터 너무많아 하면서 data.sql로 세팅해놓는경우가있는데
기존에 어떤 데이터가 있는지 확인하기 힘들다. 하지말자 파편화가 또 일어남
하나의 테스트 하나의 문서를 볼때 관계된 데이터를 보러가야함 파편화되면 너무힘듬
빌더를 다른 메소드로 뻇는데 파라미터를 제거해서 필요한 필드만 넣어서 구성하는것을 추천

클래스마다 메소드를 매번 만들기 귀찮다 그래서 광범위하게 사용하기위해 만들어서 사용한다.
라는 전략도 비추천한다 왜냐하면 자바 특성상 빌더를 사용하는데 파라미터 값들이 매번 달라지고 값도 엄청많은데
내가 필요한 빌더를 막 만들기 시작하면 관리가 안된다. 정석으로 가는게 좋다
그런데 이게 코틀린 사용하면 해소 된다
```

#### 텍스트피처 클렌징
```
deleteAll과 delteAllInBatch차이
deleteAll은 조회를 많이하고 건건히 지운다 쿼리가 많아졌다
장점은 order를 지우면서 orderproduct까지 같이 지워준다 (cascade)
외래키 매핑한거 가져와서 건당 지워주는걸 해줌
테스트 성능이 느려질 수 있음
지우는 순서는 deleteAll이랑 deleteAllInBatch둘다 해줘야함
h2쓰는건 인메모리라서 빠름
그런데 평소에는 을 써야하는데 주의하면서 써라 @Transactional 
spring Batch통합테스트하면은 여러 트랜잭션이 묶이면은 delteAllInBatch를 사용함 상황에 따라 사용하라
```


#### 반성
```
내가 작성한 테스트코드를 돌아보면은 테스트데이터를 미리 넣어두고 테스트했다.
그래서 다른사람이 보면 어느 데이터가 들어갔는데 이 테스트를하면 오류가 생긴다라는
것을 알아보기 어렵다. 즉 문서화가 안되었다 이거를 고쳐야겠다

하나의 메서드를 호출하면 발생하는 예외들을 다 테스트했다.
테스트하고자하는경우만 테스트해야하는데 목적은 주문이지만 만약 로그인 -> 주문 이면은
주문 테스트이지만 로그인을 검증하는것도 존재했다.
그래서 항상 로그인 검증을하는 로직이 들어갔는데 목적만 테스트하자
그리고 수량감소도 A메소드에서 B메소드를 호출해도 A메소드를 검증하려면은 B메소드 검증이 존재해서는안된다.
합쳐졌을떄의 검증을 해야하는것이다

```





