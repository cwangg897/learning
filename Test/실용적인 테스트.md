

#### 테스트는 [ ] 이다
```
테스트는 문서다 테스트가 하나의 클라이언트가 되어 테스트하듯이
팀원들이 테스트코드를 보고 메소드가 어떤 역할을 하는지 알 수 있다
나도 공감한다 테스트코드를 보고 어떤예외가있는지 코드 이해에 도움이 되기때문이다
```


#### DisplayName 섬세하게
```
DisplayName은 어떻게 사용해야 올바른것일가?
나는 항상 Junit4에서는 메소드에도 한글로 이름이 표현가능했다.
그런데 Junit5에서는 @Display어노테이션을 통해 표현이 가능하다
표현할때 팁은
- 테스트의 이름은 명사보다는 문장으로 표현해라
- ~테스트 이런거 지양한다
- 테스트 행위에 대한 결과까지 기술한다 ex) 음료를 1개추가하면 주문목록에 담긴다
- 섬세한 표현 ex)특정시간에 주문을 생성하면 실패한다 -> 영업시작 시간 이전에 주문을 생성할 수 없다 O  영업시작 시간이라는 용어는 우리도메인에 사용하는 언어
도메인에 맞는 용어 (영업시간 특정시간이런 용어는 도메인용어를 통해서 표현하자) 
메서드 자체의 관점보다 도메인 관점으로 보자
- 테스트의 현상을 중점으로 기술하지 말것 ex)실패한다 이런거는 테스트의 현상중점임 테스트내용과는 무관하다 성공/실패 이런 워딩은 피하고 도메인용어를 통해서 생성할 수 없다 이렇게
```


#### BDD스타일로 작성하기
```
TDD에서 파생된 개발 방법
내가 가장 선호하는 스타일이다.
함수 단위의 테스트에 집중하기 보다, 시나리오에 기반한 테스트케이스 자체에 집중하여 테스트하는것이다
개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 추상화 수준을 권장

무슨말이냐면
Given / When / Then 을 사용하는것이다
-> 이 방법을 사용하면 DisplayName에 명확하게 작성 가능하다

인텔리제이의 Live Template사용하기 어노테이션은 풀네임 적어줘야함
```


#### Junit vs Spock
```
Spock은 그루비로 테스트하는 프레임워크이다 탄생 자체가 BDD로 되어있다
Junit보다 명확하다
언어가 사고를 제한한다 (그래서 한번은 Spock을 해보는것도 좋다)
```

#### 레이어드 아키텍처와 테스트
```
레이어드 아키텍처 MVC기반에서 가장많이 사용된다
3tier, 4tier로 나누기도 한다
왜 레이어를 구분하는가? 관심사의 분리때문이다.
단위테스트만으로는 불가능해서 통합테스트가 협럭함
여러 모듈이 협럭하여 통합적으로 검증하는 테스트
```

#### Library vs Framework
```
라이브러리는 주체가 코드이고 필요한 기능을 외부에서 가져와 사용한다 이게바로 라이브러리
프레임워크는 주체가 프레임워크이다 프레임워크가 내 코드를 가져와 사용한다 (코드가 수동적)
프레임이 갖춰져있고 거기에 내코드를 넣는 것이다
```

#### 

데이터베이스에 엑세스 하는역할이 PersistenceLayer역할이다 
엑세스하는 로직만 가기고있기때문에 어찌보면 단위테스트다. 그런데 DB랑 연동이라서 통합테스트이지만 레이어만때서 하기때문에 단위
테스트 느낌이 난다 
관점차이


@DataJpaTest : 스프링서버를 띄워서 테스트하는데 차이점은 SpringBootTest보다 가볍자 JPA관련빈만 주입하기때문에 더 빠름
결론은 DataJpaTest보다 SpringBootTest를 선호한다 

리스트 검증할때는 1. 사이즈체크부터 
2. extracging검증하고자하는 필드만 추출가능하다

Persistence Layer
- Data Access의 역할
- 비즈니스 가공 로직이 포함되어서는 안된다 Data에 대한 CRUD에만 집중한 레이어
- QueryDSL쓰거나하면 비즈니스 넣는경우있는데 딱 데이터 접근만 적어야한다

Business Layer (스프링에서는 Service)
- 비즈니 로직을 구현하는 역할
- Persistence Layer와의 상호작용을 통해 비즈니스 로직을 전개 시킨다.
- 트랜잭션을 보장해야 한다 (로직전개하다가 예외발생하면 롤백해야한다 이러한것을 보장해야함)

비즈니스 레이어는 Persistence를 통합한 테스트같은 느낌이나게 작성할거임


서비스 단위로 돌리지않고 함께돌리면 duplicate오류생김
이러한걸 해결하는방법은?? 두 테스트가 서로에게 영향을 주기때문이다
2번테스트에 저장한데이터가 1번테스트에 영향을 주니까 tier다운 메서드를 통해서 afetEach를 통해서 데이터 클린 작업을한다


deleteAllInBatch와 deleteAll의 차이

repository테스트는 클렌징을 안했다 DataJpaTest가 알아서 롤백해주는거같다 가서보니가 @Transactional어노테이션이있다
롤백할려면 @Transactional 어노테이션쓰는데 이거 달아서 생기는 문제가 또 있다



