

#### 테스트는 [ ] 이다
```
테스트는 문서다 테스트가 하나의 클라이언트가 되어 테스트하듯이
팀원들이 테스트코드를 보고 메소드가 어떤 역할을 하는지 알 수 있다
나도 공감한다 테스트코드를 보고 어떤예외가있는지 코드 이해에 도움이 되기때문이다
```


#### DisplayName 섬세하게
```
DisplayName은 어떻게 사용해야 올바른것일가?
나는 항상 Junit4에서는 메소드에도 한글로 이름이 표현가능했다.
그런데 Junit5에서는 @Display어노테이션을 통해 표현이 가능하다
표현할때 팁은
- 테스트의 이름은 명사보다는 문장으로 표현해라
- ~테스트 이런거 지양한다
- 테스트 행위에 대한 결과까지 기술한다 ex) 음료를 1개추가하면 주문목록에 담긴다
- 섬세한 표현 ex)특정시간에 주문을 생성하면 실패한다 -> 영업시작 시간 이전에 주문을 생성할 수 없다 O  영업시작 시간이라는 용어는 우리도메인에 사용하는 언어
도메인에 맞는 용어 (영업시간 특정시간이런 용어는 도메인용어를 통해서 표현하자) 
메서드 자체의 관점보다 도메인 관점으로 보자
- 테스트의 현상을 중점으로 기술하지 말것 ex)실패한다 이런거는 테스트의 현상중점임 테스트내용과는 무관하다 성공/실패 이런 워딩은 피하고 도메인용어를 통해서 생성할 수 없다 이렇게
```


#### BDD스타일로 작성하기
```
TDD에서 파생된 개발 방법
내가 가장 선호하는 스타일이다.
함수 단위의 테스트에 집중하기 보다, 시나리오에 기반한 테스트케이스 자체에 집중하여 테스트하는것이다
개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 추상화 수준을 권장

무슨말이냐면
Given / When / Then 을 사용하는것이다
-> 이 방법을 사용하면 DisplayName에 명확하게 작성 가능하다

인텔리제이의 Live Template사용하기 어노테이션은 풀네임 적어줘야함
```


#### Junit vs Spock
```
Spock은 그루비로 테스트하는 프레임워크이다 탄생 자체가 BDD로 되어있다
Junit보다 명확하다
언어가 사고를 제한한다 (그래서 한번은 Spock을 해보는것도 좋다)
```

#### 레이어드 아키텍처와 테스트
```
레이어드 아키텍처 MVC기반에서 가장많이 사용된다
3tier, 4tier로 나누기도 한다
왜 레이어를 구분하는가? 관심사의 분리때문이다.
단위테스트만으로는 불가능해서 통합테스트가 협럭함
여러 모듈이 협럭하여 통합적으로 검증하는 테스트
```

#### Library vs Framework
```
라이브러리는 주체가 코드이고 필요한 기능을 외부에서 가져와 사용한다 이게바로 라이브러리
프레임워크는 주체가 프레임워크이다 프레임워크가 내 코드를 가져와 사용한다 (코드가 수동적)
프레임이 갖춰져있고 거기에 내코드를 넣는 것이다
```

#### 

데이터베이스에 엑세스 하는역할이 PersistenceLayer역할이다 
엑세스하는 로직만 가기고있기때문에 어찌보면 단위테스트다. 그런데 DB랑 연동이라서 통합테스트이지만 레이어만때서 하기때문에 단위
테스트 느낌이 난다 
관점차이


@DataJpaTest : 스프링서버를 띄워서 테스트하는데 차이점은 SpringBootTest보다 가볍자 JPA관련빈만 주입하기때문에 더 빠름
결론은 DataJpaTest보다 SpringBootTest를 선호한다 

리스트 검증할때는 1. 사이즈체크부터 
2. extracging검증하고자하는 필드만 추출가능하다

Persistence Layer
- Data Access의 역할
- 비즈니스 가공 로직이 포함되어서는 안된다 Data에 대한 CRUD에만 집중한 레이어
- QueryDSL쓰거나하면 비즈니스 넣는경우있는데 딱 데이터 접근만 적어야한다

Business Layer (스프링에서는 Service)
- 비즈니 로직을 구현하는 역할
- Persistence Layer와의 상호작용을 통해 비즈니스 로직을 전개 시킨다.
- 트랜잭션을 보장해야 한다 (로직전개하다가 예외발생하면 롤백해야한다 이러한것을 보장해야함)

비즈니스 레이어는 Persistence를 통합한 테스트같은 느낌이나게 작성할거임


서비스 단위로 돌리지않고 함께돌리면 duplicate오류생김
이러한걸 해결하는방법은?? 두 테스트가 서로에게 영향을 주기때문이다
2번테스트에 저장한데이터가 1번테스트에 영향을 주니까 tier다운 메서드를 통해서 afetEach를 통해서 데이터 클린 작업을한다


deleteAllInBatch와 deleteAll의 차이

repository테스트는 클렌징을 안했다 DataJpaTest가 알아서 롤백해주는거같다 가서보니가 @Transactional어노테이션이있다
롤백할려면 @Transactional 어노테이션쓰는데 이거 달아서 생기는 문제가 또 있다
수동으로 했는데 update쿼리가 안나갔음 그리고 롤백도 안되고 왜냐하면 서비스계층에 Transaction이 없기때문이다 
트랜잭션경계가없어서 더티체킹안됨
서비스계층에서 트랜잭션을 활용해서 할때 부작용을 알고사용해야한다
실제서비스코드에 이미 트랜잭션 어노테이션이 적용된거처럼보임
바로 문제점은 테스트코드에 트랜잭션 어노테이션이 붙여져있는데 프로덕션 코드에는 안붙여져있는데 붙여진것처럼되기때문에
혹시나 하는 문제가 발생한다 그래서 트랜잭션 어노테이션을 테스트계층에서 사용하는것은 잘알고써야한다 부작용을 인지해야한다
save는 기본적으로 @Transactional이 걸려있음





재고수량 왜 더블체크하나요?
관점을 서비스에서 진행한 체크는 주문생성로직을 하다가 재고차감을 진행하는것이고
Stock클래스 자체에서 체크하는것은 서비스자체를 모르고 수량차감시에 올바른 수량을 보장해야하기때문에

서비스에서 던지는거랑 Stock엔티티에서 던지는것은 다르다.
더블체크하는게 답인듯 또한 메시지 자체를 다르게 주고싶을 수도있음 - 서비스 쪽은 사용자 친화적



코드 스트림 활용 잘하는게 좋은듯
        stockProductNumbers.stream()
                .collect(Collectors.groupingBy(p -> p, Collectors.counting()));
스트림 모르는거 



#### Presentation 계층
```
외부 세계의 요청을 가장 먼저 받는계층
파라미터에 대한 최소한의 검증을 수행한다
표현계층에서는 Validation이 매우중요하다(비즈니스 로직실행전)
표현계층을 테스트할때는 하위 비즈니스와 데이터 계층을 모킹하고 진행한다.
모킹 이라는 것은 가짜 객체로 대신하여 정상동작을 하는거입니다.
그래서 테스트 하고자하는 계층에만 집중해서 테스트하겠다라는것이다.
```

#### Mock
```
Mock은 가짜라는 뜻으로 
MockMvc 
의존관계를 가지고 테스트할때 방해가 된다 테스트하기위해
준비해야하는것이 너무 많을때 가짜로 처리하고싶다 라고할때 Mock을사용하는데
MockMvc프레임워크 사용한다.
MockMvc란 스프링 MVC동작을 재현할 수 있는 테스트 프레임워크다

```


#### 동시성
```
uniquekey로 하면은 재시도를 만들거나
빈도수가 엄청 높진않은경우 시스템에서 재시도하는거고
크리티컬한 케이스는 상품등록이랑 다른문제지만 아예 상품번호 생성에 대한 정책을 UUID로 가져갈 수도있다.
```

#### 테스트
```
테스트가 상품번호를 체크하는것도 있지만 이런것도 체크하고 상품번호를 생성하고 저장하는거니까 저장을
테스트하는게 맞다

빌더가 좋긴하지만 request랑 response에서 빌더를 스테틱 메서드로(팩토리 메서드)패턴으로 숨기는게 더 가독성 높음
서비스 로직만 볼 수 있도록 
```

#### @Transactional
```
readOnly = true 읽기전용 default false
true로 하면 CUD동작 x / only Read
JPA에서 CUD는 스냅샷저장하는데 true면은 변경감지 x (성능 향상 됨)

가장중요한것은
CQRS - Command 랑 Read를 분리하자
command : CUD
보통 서비스는 커맨드보다 Read빈도수가 더 높다
그래서 CQRS라는 커맨드랑 리드의 책임을 의도적으로 분리하자
책임을 분리해서 연관이 없게하자
ex) 사용자가 read가 몰려 시스템 부하가 생길때 커맨드가 같이 동작을 안해버리면
더 큰 장애가 된다 반대의 상황도 마찬가지 그래서 이런 것을 분리하자의
첫번째 시작이 트랜잭션의 read only true을 신경써서 작성해야한다
그러면 이런거 master db slave db나눌수있는 가장큰장점
리더 db로 보내자 이런거 설정가능함

추천하는 방법은 Service계층에 상단에 read Only로 전체적으로 걸고
CUD작업에는 따로걸면은 누락하면은 테스트에서 꺠지니까 알 수 있다
```

#### Persentation Layer Test
```
MockMvc를 활용한다.
추가로 MockBean을 Service(비즈니스계층)을 한다
@MockBean을 하면 애초에 ProductService가 빈으로 관리되는데 이것을 가짜빈을 컨테이너에 넣어준다
만약없으면 빈이없다고 나올것이다
request에 Noargs가 필요한것은 objectmapper가 역직렬화 할 때 기본생성자를 사용한다 이런원리 공부하기 한번씩
응답에 대한 규격을 꼭 설정해라
내가하던 방식이 맞긴 맞았다 항상 의문을 가졌는데 다행이다

그런데 기본적인것만 validation을 해라 20자 제한 이런것은 비즈니스에서 검증을 하든 도메인객체에서 검증을하든
안쪽에서 하는게 맞다 벨리데이션에대한 책임을 어떻게 분리할지
계층분리할려고 하위는 상위를 알면안좋으니까 request를  컨트롤러 request에서 service request로 변환해서 사용한다
의존관계를 줄일려고 노력
서비스가 starter validation을 들고가지않아도된다는 장점 validation책임분리
만약 컨트롤러의 request 변경이 일어나도 서비스단의 코드는 변경을 안해도된다는 장점
```
